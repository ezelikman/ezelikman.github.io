<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Take the Scenic Route üó∫Ô∏è</title>

    <!-- Include Leaflet CSS and JavaScript -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css">
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://unpkg.com/@mapbox/polyline"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">

    <!-- Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-V8HMZSX4TF"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-V8HMZSX4TF');
    </script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            color: #333;
            margin: 0;
            padding: 0;
            background-color: #f0f0f0;
        }

        #title {
            position: absolute;
            z-index: 1;
            top: 10px;
            left: 50%;
            transform: translateX(-50%); /* center the title */
            padding: 10px 20px; /* space around the text */
            font-size: 2em;
            text-align: center;
            color: #1a1a1a;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 8px;
            width: fit-content;
            white-space: nowrap;
        }
    

        #map {
            position: fixed;
            z-index: 0;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
        }

        .input-control {
            position: absolute;
            z-index: 1;
            top: 9%;  /* adjust as needed */
            width: 90%;
            left: 50%;
            transform: translateX(-50%); /* center the title */
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0px 10px;
            margin: 15px 0;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.15);
        }

        #description {
            position: absolute;
            z-index: 1;
            bottom: 0;
            width: 85%;
            background-color: rgba(255, 255, 255, 0.8);
            margin: 5%;
            padding: 2.5%;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.15);
            overflow-y: auto;
            max-height: 30%;
        }

        .input-control input {
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #ccc;
            flex: 1 1 auto;
            margin: 2px;
        }

        .input-control button {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            background-color: #007bff;
            color: #fff;
            cursor: pointer;
            flex: 1 1 auto;
            margin: 2px;
        }

        .input-control select {
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #ccc;
            flex: 1 1 auto;
            margin: 2px;
        }

        .input-control button:hover {
            background-color: #0056b3;
        }

        .api-key-help {
            display: flex;
            justify-content: center;
            margin-bottom: 10px;
        }

        .api-key-help a {
            color: #5d5d5d;
            text-decoration: none;
        }

        .api-key-help a:hover {
            text-decoration: underline;
        }

        @media (max-width: 418px) {
            #title {
                font-size: 1.2em;
            }
            
            
            .input-control input, .input-control button, .input-control select {
                width: 30%;
                min-width: 30%;
                margin-bottom: 10px;
            }
        }
    </style>
</head>
<body>
    <h1 id="title">Take the Scenic Route üó∫Ô∏è</h1>
    <div class="input-control">
        <input type="text" id="start" placeholder="Start location">
        <input type="text" id="end" placeholder="End location">
        <input type="text" id="time" placeholder="Extra time (minutes)">
        <input type="text" id="routeProperties" placeholder="What kind of stops?">

        <select id="vehicle" name="vehicle">
            <option value="car">Car</option>
            <option value="foot">Foot</option>
            <option value="hike">Hike</option>
            <option value="wheelchair">Wheelchair</option>
            <option value="bike">Bike</option>
            <option value="racingbike">Racing Bike</option>
            <option value="mtb">Mountain Bike</option>
            <option value="motorcycle">Motorcycle</option>
        </select>    

        <button id="submit" onclick="updateRoute()">Submit</button>
    </div>

<!--     <div class="api-key-help">
        <a href="https://platform.openai.com/account/api-keys" target="_blank">Find your OpenAI API Key</a>
    </div> -->

    <div id="map"></div>

    <div id="description">
        <!-- Replace this placeholder text as required -->
        <p>Your route description will appear here...</p>
    </div>
    
    <script>
        // Initialize the map
        var map = L.map('map').setView([51.505, -0.09], 13);
        var markers = [];

        // Add OpenStreetMap tiles to the map
        L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
            maxZoom: 19,
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>'
        }).addTo(map);


        var polylineLayer = null;

        // Function to fetch coordinates from the GraphHopper Geocoding API
        async function getCoordinates(apiKey, location) {
            const response = await fetch(`https://graphhopper.com/api/1/geocode?q=${encodeURIComponent(location)}&key=${apiKey}`);
            const data = await response.json();
            if (!data.hits[0] || response.status !== 200) {
                document.getElementById('description').innerHTML = document.getElementById('description').innerHTML + "<br>" + 'Could not find location: ' + location;
                return null;
            }

            return data.hits[0].point;
        }

        // Function to fetch a route from the GraphHopper Routing API
        async function getRoute(apiKey, points) {
            const pointParams = points.map(({ lat, lng }) => `point=${lat},${lng}`).join('&');
            const vehicle = document.getElementById("vehicle").value; // get the selected vehicle
            const response = await fetch(`https://graphhopper.com/api/1/route?${pointParams}&vehicle=${vehicle}&key=${apiKey}`);
            // Check if the response is undefined or not successful
            if (!response || response.status !== 200) {
                return null;
            }

            const data = await response.json();
            const routePoints = polyline.decode(data.paths[0].points);
            const routeTime = data.paths[0].time; // in milliseconds

            return {
                points: routePoints,
                time: routeTime / 1000 / 60 // in minutes
            };
        }

        // Function to generate a response using OpenAI's GPT model
        async function generateResponse(start, end, properties, maxExtraTime, vehicle) {
            const response = await fetch('https://us-central1-scenic-393123.cloudfunctions.net/function-1', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    "start": start,
                    "end": end,
                    "properties": properties,
                    "maxExtraTime": maxExtraTime,
                    "vehicle": vehicle
                })
            });
            const data = await response.text();
            return data;
        }

        // Function to update the route
        async function updateRoute() {
            var maxExtraTime = document.getElementById('time').value;
            if (!maxExtraTime) {
                document.getElementById('description').innerHTML = "Route description will go here. Make sure to fill in the extra time field. For example, if you're willing to spend 120 minutes longer than the most direct route, put 120 as extra time.";
                return;
            }
            if (isNaN(maxExtraTime)) {
                document.getElementById('description').innerHTML = 'Make sure you put in a valid number for extra time.';
                return;
            }

            var apiKey1 = '09207d7d'
            var apiKey2 = '7b52'
            var apiKey3 = '4a06'
            var apiKey4 = 'a684'
            var apiKey5 = '2c36f4dbb7cd'
            var apiKey = apiKey1 + '-' + apiKey2 + '-' + apiKey3 + '-' + apiKey4 + '-' + apiKey5;
            var start = document.getElementById('start').value;
            var end = document.getElementById('end').value;

            // Update the description
            document.getElementById('description').innerHTML = 'Calculating route from ' + start + ' to ' + end + '...' + '<br>' + '<img src="https://cdn.pixabay.com/animation/2022/07/29/03/42/03-42-22-68_512.gif" width="50" height="50">';

            var startCoordinates = await getCoordinates(apiKey, start);
            var endCoordinates = await getCoordinates(apiKey, end);

            // Remove previous markers
            for (let i = 0; i < markers.length; i++) {
                map.removeLayer(markers[i]);
            }
            markers = [];
            // Add markers for the start and end locations
            markers.push(L.marker([startCoordinates.lat, startCoordinates.lng]).addTo(map));
            markers.push(L.marker([endCoordinates.lat, endCoordinates.lng]).addTo(map));
            map.fitBounds(markers.map(m => m.getLatLng()));
            

            var routeData = await getRoute(apiKey, [startCoordinates, endCoordinates]);

            if (!routeData) {
                document.getElementById('description').innerHTML = 'Could not find a route between ' + start + ' and ' + end;
                return;
            }
            var routeCoordinates = routeData.points;
            var routeTime = routeData.time; // Time in milliseconds

            var latlngs = routeCoordinates.map(function(c) {
                return [c[0], c[1]];
            });

            if (polylineLayer != null) {
                map.removeLayer(polylineLayer);
            }

            polylineLayer = L.polyline(latlngs).addTo(map);
            map.fitBounds(polylineLayer.getBounds());

            var properties = document.getElementById('routeProperties').value;
            let vehicle = document.getElementById("vehicle").value;
            // Example of how to generate a response from GPT
            var gptResponse = await generateResponse(start, end, properties, maxExtraTime, vehicle);
            console.log(gptResponse);

            function parseLocationsAndDescriptions(gptResponse) {
                const regex = /\d+\. ([^:]*): ([^.]*)./g;
                let match;
                let locations = [];
                let descriptions = [];

                while ((match = regex.exec(gptResponse)) !== null) {
                    locations.push(match[1]);
                    descriptions.push(match[2]);
                }

                return [locations, descriptions];
            }

            var locationsAndDescriptions = parseLocationsAndDescriptions(gptResponse);
            var locations = locationsAndDescriptions[0];
            var descriptions = locationsAndDescriptions[1];
            
            // For each location, attempt to add it to the route and see if the impact is within the time limit
            // If it is, add it to the route and continue
            // If it isn't, continue to the next location
            // If there are no more locations, stop
            // var stops = document.getElementById('stops').value;
            var newPath = [startCoordinates];
            var newPathDescription = [];
            var finalRouteData = null;
            var googleMapsLink = "https://www.google.com/maps/dir/";
            googleMapsLink += encodeURIComponent(start) + '/';  // add start location to Google Maps link

            // Generate an array of indices from 0 to locations.length-1
            var indices = Array.from({length: locations.length}, (_, i) => i);

            // Shuffle the array of indices
            for (var i = indices.length - 1; i > 0; i--) {
                var j = Math.floor(Math.random() * (i + 1));
                var temp = indices[i];
                indices[i] = indices[j];
                indices[j] = temp;
            }

            var validLocations = Array(locations.length).fill(null);

            for (var i = 0; i < indices.length; i++) {
                // Use the shuffled indices to access locations and descriptions
                var location = locations[indices[i]];
                var description = descriptions[indices[i]];

                // Check and store the location in the original order
                var locationCoordinates = await getCoordinates(apiKey, location);
                if (!locationCoordinates) {
                    continue;
                }
                var tempPath = [...newPath, locationCoordinates, endCoordinates];
                var tempRouteData = await getRoute(apiKey, tempPath);
                if (!tempRouteData) {
                    continue;
                }

                var tempRouteTime = tempRouteData.time;
                // Check if the time is within the limit
                if (tempRouteTime - routeTime < maxExtraTime) {
                    validLocations[indices[i]] = {
                        locationCoordinates: locationCoordinates,
                        location: location,
                        description: description
                    };
                }
            }

            // Add valid locations to the newPath
            for (var i = 0; i < validLocations.length; i++) {
                if (validLocations[i] !== null) {
                    newPath.push(validLocations[i].locationCoordinates);
                    finalRouteData = await getRoute(apiKey, [...newPath, endCoordinates]);
                    // Concat the place and description and then push it to the array
                    newPathDescription.push(`<b>${validLocations[i].location}</b>: ${validLocations[i].description}`);
                    // Add a marker for the added stop
                    let marker = L.marker([validLocations[i].locationCoordinates.lat, validLocations[i].locationCoordinates.lng]);
                    marker.bindPopup(`${validLocations[i].location}: ${validLocations[i].description}`);
                    googleMapsLink += encodeURIComponent(validLocations[i].location) + '/';  // add each valid location to Google Maps link
                    markers.push(marker);
                    marker.addTo(map);
                }
            }
            googleMapsLink += encodeURIComponent(end) + '/';  // add end location to Google Maps link

            var finalRouteTime = finalRouteData.time;
            console.log(finalRouteTime);

            // Update the map with the new route
            var finalRouteCoordinates = finalRouteData.points;
            var finalLatlngs = finalRouteCoordinates.map(function(c) {
                return [c[0], c[1]];
            });

            if (polylineLayer != null) {
                map.removeLayer(polylineLayer);
            }

            polylineLayer = L.polyline(finalLatlngs).addTo(map);
            map.fitBounds(polylineLayer.getBounds());

            // Add the descriptions to the HTML
            document.getElementById('description').innerHTML = newPathDescription.join("<br>") + "<br><br>" + '<b>Google Maps Link</b>: <a href="'+googleMapsLink+'" target="_blank">Click here</a>';

            console.log(newPathDescription);
        }
    </script>
</body>
</html>
